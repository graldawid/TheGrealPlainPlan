# Production Context — The Great Plain Plan

## Current Phase
MVP Production

## File Safety & Code Commenting Rules (STRICT)

### File Modification Safety
The assistant MUST NOT modify, rewrite, or propose changes to any existing file unless:

1. The user has explicitly provided the CURRENT version of the file.
2. The assistant has confirmed that this is the latest version.

If the assistant identifies a need to change a file, it MUST first respond with:
"Please paste the current version of <file path> so I can safely propose changes."

The assistant is NOT allowed to assume file contents based on memory or previous chats.

### Code Commenting Requirement
Every piece of code written by the assistant MUST include clear, intentional comments.

Comments MUST:
- Explain WHY the code exists, not only WHAT it does
- Reference the related system or concept from the repository documentation
- Be written so that a future ChatGPT instance can understand the logic without prior chat context

Code without comments is considered INVALID.

These rules are mandatory for the entire MVP production.

## MVP Goal
Deliver a playable MVP of a 2D arcade roguelike based on deterministic launch-and-flight gameplay within 14 days.

## Core Rules
- GitHub repository is the single source of truth
- ChatGPT is an assistant, not memory
- Every decision, change, or new system MUST be logged in repo
- No scope expansion during MVP
- Placeholder assets only

## Locked Decisions
- 2D Unity
- Deterministic pseudophysics (no Rigidbody)
- Side-scrolling launch flight (Burrito-like)
- Static camera in MVP
- 1 map, 1 hero, vendor, items
- Multiplayer NOT in MVP

## What Is Being Built Right Now
- Unity project setup
- Core flight architecture
- GameManager & state handling

## How To Work
For every task:
1. Implement or design
2. Identify:
   - DECISION / CHANGE / NEW INFO / TODO
3. Specify:
   - File path in repo
4. Update documentation

## Assistant Operating Mode (Mandatory)

The assistant must assume the user has NO technical or procedural knowledge.

## Rules:
- Always provide step-by-step instructions.
- Always specify:
  - Where to click
  - What menu to open
  - What button to press
- Never skip setup steps.
- Never assume the project already exists or is open.
- After each step, the assistant must WAIT for confirmation before continuing.
- If a step is not completed, the assistant must repeat or rephrase instructions.

This mode is mandatory for all MVP production days.

## End-of-Day Summary Protocol (Mandatory)

At any point, the user may request:
"Summarize what we did today."

## End-of-Day Report (STRICT FORMAT)

When the user says:
"Podsumuj, co zrobiliśmy dzisiaj"

The assistant MUST output ONLY the following structure.
NO explanations. NO commentary. NO extra text.

---

# END OF DAY REPORT

## DAY
DAY X — <day name>

## DECISIONS
- [DECYZJA] <one sentence>

## CHANGES
- [ZMIANA] <one sentence>

## NEW FILES
- <file path> — <what this file does>

## MODIFIED FILES
- <file path> — <what was changed>

## CURRENT STATE
- What works:
- What is implemented:
- What is missing:

## NEXT DAY
- Next production day:
- Exact next task:

---

The report must be:
- concise
- factual
- copy-paste ready
- understandable by a new ChatGPT instance

This format is mandatory.




## REPORTS:

END OF DAY REPORT

DAY
DAY 1 — Project Setup & Boot Flow

DECISIONS

[DECYZJA] Unity Input System (New) jest jedynym systemem inputu w MVP.

[DECYZJA] Boot Scene jest jedynym entry pointem gry i obsługuje wyłącznie „Press Start” → MainMenu.

CHANGES

[ZMIANA] Zakres DAY 1 został rozszerzony o implementację Boot Scene i unified input.

NEW FILES

/Assets/Scenes/Boot.unity — scena startowa gry z napisem „PRESS START”.

/Assets/Scenes/MainMenu.unity — pusta scena menu głównego (placeholder).

/Assets/Scripts/Core/BootInputListener.cs — obsługa „Press Start” z klawiatury, myszy i gamepada (Input System).

MODIFIED FILES

/PRODUCTION_CONTEXT.md — aktualizacja DAY 1 o Boot Flow i decyzję dot. Input System.

CURRENT STATE

What works:
Boot Scene uruchamia się jako pierwsza; „PRESS START” reaguje na klawiaturę, mysz i pad; następuje przejście do MainMenu.

What is implemented:
Projekt Unity 2D; struktura folderów; Boot Flow end-to-end.

What is missing:
Logika Main Menu; GameManager i GameState; gameplay.

NEXT DAY

Next production day:
DAY 2 — Main Menu & Core State Skeleton

Exact next task:
Implementacja Main Menu UI oraz szkieletu GameManager + GameState.

END OF DAY REPORT

DAY
DAY 2 — Main Menu UI & Basic Interaction

DECISIONS

[DECYZJA] Main Menu w MVP składa się z trzech przycisków: Play, Options, Exit, bez dodatkowej nawigacji na tym etapie.

[DECYZJA] Logika przycisków menu jest obsługiwana przez prosty MenuController bez zależności od GameManagera.

CHANGES

[ZMIANA] Dodano interaktywną scenę MainMenu zamiast pustego placeholdera.

NEW FILES

/Assets/Scripts/Core/MenuController.cs — kontroler obsługujący akcje przycisków Play, Options i Exit w Main Menu.

MODIFIED FILES

/Assets/Scenes/MainMenu.unity — dodano Canvas, layout UI oraz trzy przyciski z podpiętymi akcjami.

/PRODUCTION_CONTEXT.md — aktualizacja o realizację DAY 2.

CURRENT STATE

What works:
Main Menu wyświetla się poprawnie; przyciski reagują na kliknięcie; Play i Options logują akcje; Exit zatrzymuje Play Mode.

What is implemented:
UI Main Menu; podstawowa obsługa przycisków; oddzielny kontroler menu.

What is missing:
Nawigacja klawiatura/pad po menu; przejście Play do gameplayu; GameManager i system stanów.

NEXT DAY

Next production day:
DAY 3 — GameManager & Game State Skeleton

Exact next task:
Utworzenie GameManagera oraz enumu GameState i podpięcie ich do przepływu Boot → MainMenu.

DAY 3 — Meta Flow (Map Select → Hero Select → Run)

DECISIONS

[DECYZJA] Meta flow gry realizowany jest w jednej scenie (MetaFlow) sterowanej przez GameState.

[DECYZJA] GameManager działa jako singleton z auto-bootstrapem, niezależnie od kolejności uruchamiania scen.

CHANGES

[ZMIANA] Dodano zabezpieczenie GameManagera przed brakiem instancji (auto-tworzenie przy pierwszym użyciu).

NEW FILES

/Assets/Scenes/MetaFlow.unity — scena meta zawierająca MapSelect i HeroSelect.

/Assets/Scripts/Core/MapSelectController.cs — obsługa wyboru mapy i przejścia do HeroSelect.

/Assets/Scripts/Core/HeroSelectController.cs — obsługa wyboru bohatera i przejścia do stanu Run.

MODIFIED FILES

/Assets/Scripts/Core/GameManager.cs — dodano mechanizm EnsureInstance zabezpieczający przed NullReference.

/Assets/Scripts/Core/MenuController.cs — Play prowadzi do sceny MetaFlow.

/PRODUCTION_CONTEXT.md — aktualizacja o realizację DAY 3.

CURRENT STATE

What works:
Boot → MainMenu → MetaFlow → MapSelect → HeroSelect → Run działa bez błędów.

What is implemented:
Meta flow gry, GameState, GameManager, placeholder MapSelect i HeroSelect z testowymi sprite’ami.

What is missing:
Scena Run / gameplay, logika lotu, plansza, system runu.

NEXT DAY

Next production day:
DAY 4 — Run Scene & Flight Skeleton

Exact next task:
Utworzenie sceny Run oraz szkieletu FlightController z deterministycznym ruchem.

DAY
DAY 4 — HeroTemplate & Flight Skeleton

DECISIONS

[DECYZJA] HeroTemplate jest docelowym źródłem danych bohatera i zastępuje wcześniejsze pojęcie HeroBase.

[DECYZJA] Obiekt Hero w scenie Run jest generyczną instancją runtime, a nie konkretnym bohaterem.

[DECYZJA] Flight w MVP jest deterministyczny i nie używa Rigidbody ani Physics.

CHANGES

[ZMIANA] Priorytetem po MetaFlow stało się zbudowanie Run i Flight Skeleton zamiast dalszego UX MetaFlow.

NEW FILES

/Assets/Scripts/Hero/HeroTemplate.cs — ScriptableObject definiujący statystyki lotu bohatera.

/Assets/Data/HeroTemplates/Hero_Test_01.asset — testowy HeroTemplate używany do pierwszego runu.

/Assets/Scenes/Run.unity — scena gameplayowa Run (placeholder pod flight).

/Assets/Scripts/Flight/FlightController.cs — kontroler deterministycznego lotu wykorzystujący HeroTemplate.

MODIFIED FILES

/PRODUCTION_CONTEXT.md — aktualizacja o realizację DAY 4.

CURRENT STATE

What works:
Scena Run ładuje się poprawnie; bohater startuje lot; porusza się deterministycznie; lot kończy się po czasie bez błędów.

What is implemented:
HeroTemplate jako dane; Run Scene; FlightController skeleton; połączenie Run z danymi bohatera.

What is missing:
Wejście do Run z MetaFlow; kolizje; board/mapa; checkpointy; UI runu.

NEXT DAY

Next production day:
DAY 5 — Run Integration & Launch Control

Exact next task:
Podpięcie wejścia do Run z MetaFlow oraz kontrola startu lotu (launch trigger zamiast auto-start).

DAY 5 — Run Orchestration, Launch Control & Hero Transfer

DECISIONS

[DECYZJA] Start lotu nie odbywa się automatycznie; flight uruchamiany jest wyłącznie przez jawny input (launch).

[DECYZJA] Run posiada własny RunController, który zarządza stanem runu niezależnie od FlightController.

[DECYZJA] HeroTemplate jest przekazywany z MetaFlow do Run przez GameManager jako transient storage.

CHANGES

[ZMIANA] FlightController przestał sam inicjować lot i komunikuje start/koniec lotu do RunController.

[ZMIANA] GameManager został rozszerzony o pole przechowujące aktualnie wybrany HeroTemplate.

NEW FILES

/Assets/Scripts/Core/RunState.cs — enum definiujący stany runu (Idle, Flying, Finished).

/Assets/Scripts/Core/RunController.cs — kontroler zarządzający przebiegiem runu i reagujący na start/koniec lotu.

MODIFIED FILES

/Assets/Scripts/Flight/FlightController.cs — dodano ręczny launch na input oraz sygnały start/koniec lotu do RunController.

/Assets/Scripts/Core/GameManager.cs — dodano pole SelectedHeroTemplate do przekazywania danych z MetaFlow do Run.

/Assets/Scripts/Core/HeroSelectController.cs — ustawianie wybranego HeroTemplate i przejście do sceny Run.

/PRODUCTION_CONTEXT.md — aktualizacja o realizację DAY 5.

CURRENT STATE

What works:
Full flow Boot → MainMenu → MetaFlow → HeroSelect → Run → Launch → Flight → End działa bez błędów.

What is implemented:
Run orchestration, ręczny launch, deterministyczny flight, przekazywanie HeroTemplate do Run, jawny RunState.

What is missing:
Landing logic, liczenie dystansu, wynik runu, board/checkpointy, UI runu.
